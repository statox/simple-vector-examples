import"../chunks/DsnmJJEf.js";import{o as ie}from"../chunks/CVJGeIlM.js";import{S as le,_ as W,$ as Y,l as he,V as ve,m as de,X as pe,T as o,Y as n,C as l,a0 as $,F as q,n as v,Z as s}from"../chunks/DPwOY9Ev.js";import{V as G,s as c,P as ue}from"../chunks/COKwq80w.js";import{M as fe}from"../chunks/BSFgzAEw.js";import{M as ge}from"../chunks/B17B5uQ6.js";var me=he(`<!> <div><p>On the first screen you can drag the input vector <span>v1</span> the input vector. This is the vector we are calling <code>.reflect()</code> on.</p> <p>You can also drag the <span>normal</span> vector. This is the
        argument we pass to <code>v1.reflect(normal)</code>. It represent the normal vector of the
        surface that <span>v1</span> will be reflected on. This surface is rendered as the black line on the second screen.</p> <p>And you can observe how the <span>reflected</span> vector evolves.</p> <p>The second screen is another representation to help visualize how <code>.reflect</code> works. It shows:</p> <ul><li><span>v1</span> as pointing toward the surface it will be reflected
            on. (The surface is the black line).</li> <li><span>normal</span> pointing out of the surface at the
            point where <span>v1</span> intersects the surface.</li> <li>And <span>reflected</span> as going out from this impact
            point.</li></ul> <p><strong>Note</strong> how when <span>v1</span> and <span>normal</span> are perpendicular, ie. when the vector is parallel to the surface to reflect on, <span>reflected</span> keeps the same direction. In a physical simulation that's an edge case to handle before (or after)
        calling <code>.reflect()</code>.</p> <p><strong>Note</strong> the magnitude of the <span>normal</span> vector doesn't impact the result of <code>.reflect()</code> (Because the method normalize it
        before doing its computation)</p></div> <div class="results svelte-6zq5v2"><div><h3><code>Input</code></h3> <!></div></div> <!>`,1);function xe(O,R){le(R,!0);let V,f=W(Y(new G(3,3))),g=W(Y(new G(0,1))),X=$(()=>l(f).clone().reflect(l(g)));const Z="#00FF00",j="#FF0000",E="#6e6ef4",u=$(()=>[{name:"v1",vec:l(f),color:Z,onUpdate:e=>{q(f,e.clone().fixPrecision(1),!0)},isDraggable:!0},{name:"normal",vec:l(g),color:j,onUpdate:e=>{q(g,e.clone().fixPrecision(1),!0)},isDraggable:!0},{name:"v1.reflect(normal)",vec:l(X),color:E,isDraggable:!1}]),m={size:10,graduation:1},p=(e,t,a)=>{const r=e.width/2+a*t.x,i=e.height/2-a*t.y;e.strokeWeight(3);try{const d=t.clone().invert().rotateByDeg(45).resize(10);e.line(r,i,r+d.x,i-d.y);const h=t.clone().invert().rotateByDeg(-45).resize(10);e.line(r,i,r+h.x,i-h.y),e.line(e.width/2,e.height/2,r,i)}catch{e.circle(e.width/2,e.height/2,10)}},H=(e,t,a)=>{e.stroke(125,80),e.strokeWeight(1);for(let r=0;r<t.size/t.graduation;r++){const i=e.width/2+r*a*t.graduation;e.line(i,0,i,e.height);const d=e.width/2-r*a*t.graduation;e.line(d,0,d,e.height);const h=e.height/2+r*a*t.graduation;e.line(0,h,e.width,h);const U=e.height/2-r*a*t.graduation;e.line(0,U,e.width,U)}},J=(e,t)=>e.width/t.size,K=e=>{e.setup=()=>{V=e,e.createCanvas(300,300)},e.draw=()=>{const t=J(e,m);e.background(240,240,240),H(e,m,t);const a=l(u)[0];e.stroke(a.color),e.push(),e.translate(-a.vec.x*t,a.vec.y*t),p(e,a.vec,t),e.pop();const r=l(u)[1];e.stroke(r.color),p(e,r.vec,t);const i=r.vec.clone().resize(10).rotateByDeg(90),d=r.vec.clone().resize(10).rotateByDeg(-90);e.stroke("black"),p(e,i,t),p(e,d,t);const h=l(u)[2];e.stroke(h.color),p(e,h.vec,t)}};ie(()=>{V?.remove()});var A=me(),M=ve(A);fe(M,{title:"Reflect methods"});var w=o(M,2),_=n(w),L=o(n(_));c(L,"color: #00FF00"),v(3),s(_);var F=o(_,2),P=o(n(F));c(P,"color: #FF0000");var Q=o(P,4);c(Q,"color: #00FF00"),v(),s(F);var y=o(F,2),ee=o(n(y));c(ee,"color: #6e6ef4"),v(),s(y);var k=o(y,4),b=n(k),te=n(b);c(te,"color: #00FF00"),v(),s(b);var x=o(b,2),T=n(x);c(T,"color: #FF0000");var oe=o(T,2);c(oe,"color: #00FF00"),v(),s(x);var B=o(x,2),re=o(n(B));c(re,"color: #6e6ef4"),v(),s(B),s(k);var z=o(k,2),C=o(n(z),2);c(C,"color: #00FF00");var I=o(C,2);c(I,"color: #FF0000");var ae=o(I,2);c(ae,"color: #6e6ef4"),v(3),s(z);var N=o(z,2),ne=o(n(N),2);c(ne,"color: #FF0000"),v(3),s(N),s(w);var D=o(w,2),S=n(D),se=o(n(S),2);ge(se,{get grid(){return m},get vectors(){return l(u)}}),s(S),s(D);var ce=o(D,2);ue(ce,{sketch:K}),de(O,A),pe()}export{xe as component};
