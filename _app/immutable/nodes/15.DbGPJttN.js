import"../chunks/DsnmJJEf.js";import{o as ce}from"../chunks/BVhCGFvA.js";import{D as ie,Q as O,R,F as le,G as o,I as he,K as ve,M as de,O as s,z as l,S,B as U,T as v,P as n}from"../chunks/DUP_8v5R.js";import{V as W,s as c,M as ue,P as pe}from"../chunks/CfXP_IzQ.js";var fe=le(`<h2>Reflect</h2> <div><p>On the first screen you can drag the input vector <span>v1</span> the input vector. This is the vector we are calling <code>.reflect()</code> on.</p> <p>You can also drag the <span>normal</span> vector. This is the
        argument we pass to <code>v1.reflect(normal)</code>. It represent the normal vector of the
        surface that <span>v1</span> will be reflected on. This surface is rendered as the black line on the second screen.</p> <p>And you can observe how the <span>reflected</span> vector evolves.</p> <p>The second screen is another representation to help visualize how <code>.reflect</code> works. It shows:</p> <ul><li><span>v1</span> as pointing toward the surface it will be reflected
            on. (The surface is the black line).</li> <li><span>normal</span> pointing out of the surface at the
            point where <span>v1</span> intersects the surface.</li> <li>And <span>reflected</span> as going out from this impact
            point.</li></ul> <p><strong>Note</strong> how when <span>v1</span> and <span>normal</span> are perpendicular, ie. when the vector is parallel to the surface to reflect on, <span>reflected</span> keeps the same direction. In a physical simulation that's an edge case to handle before (or after)
        calling <code>.reflect()</code>.</p> <p><strong>Note</strong> the magnitude of the <span>normal</span> vector doesn't impact the result of <code>.reflect()</code> (Because the method normalize it
        before doing its computation)</p></div> <div class="results svelte-6zq5v2"><div><h3><code>Input</code></h3> <!></div></div> <!>`,1);function Fe(q,K){ie(K,!0);let P,f=O(R(new W(3,3))),g=O(R(new W(0,1))),Q=S(()=>l(f).clone().reflect(l(g)));const Y="#00FF00",j="#FF0000",E="#6e6ef4",p=S(()=>[{name:"v1",vec:l(f),color:Y,onUpdate:e=>{U(f,e.clone().fixPrecision(1),!0)},isDraggable:!0},{name:"normal",vec:l(g),color:j,onUpdate:e=>{U(g,e.clone().fixPrecision(1),!0)},isDraggable:!0},{name:"v1.reflect(normal)",vec:l(Q),color:E,isDraggable:!1}]),m={size:10,graduation:1},u=(e,t,a)=>{const r=e.width/2+a*t.x,i=e.height/2-a*t.y;e.strokeWeight(3);try{const d=t.clone().invert().rotateByDeg(45).resize(10);e.line(r,i,r+d.x,i-d.y);const h=t.clone().invert().rotateByDeg(-45).resize(10);e.line(r,i,r+h.x,i-h.y),e.line(e.width/2,e.height/2,r,i)}catch{e.circle(e.width/2,e.height/2,10)}},H=(e,t,a)=>{e.stroke(125,80),e.strokeWeight(1);for(let r=0;r<t.size/t.graduation;r++){const i=e.width/2+r*a*t.graduation;e.line(i,0,i,e.height);const d=e.width/2-r*a*t.graduation;e.line(d,0,d,e.height);const h=e.height/2+r*a*t.graduation;e.line(0,h,e.width,h);const N=e.height/2-r*a*t.graduation;e.line(0,N,e.width,N)}},J=(e,t)=>e.width/t.size,L=e=>{e.setup=()=>{P=e,e.createCanvas(300,300)},e.draw=()=>{const t=J(e,m);e.background(240,240,240),H(e,m,t);const a=l(p)[0];e.stroke(a.color),e.push(),e.translate(-a.vec.x*t,a.vec.y*t),u(e,a.vec,t),e.pop();const r=l(p)[1];e.stroke(r.color),u(e,r.vec,t);const i=r.vec.clone().resize(10).rotateByDeg(90),d=r.vec.clone().resize(10).rotateByDeg(-90);e.stroke("black"),u(e,i,t),u(e,d,t);const h=l(p)[2];e.stroke(h.color),u(e,h.vec,t)}};ce(()=>{P?.remove()});var A=fe(),w=o(he(A),2),_=s(w),X=o(s(_));c(X,"color: #00FF00"),v(3),n(_);var F=o(_,2),B=o(s(F));c(B,"color: #FF0000");var Z=o(B,4);c(Z,"color: #00FF00"),v(),n(F);var y=o(F,2),$=o(s(y));c($,"color: #6e6ef4"),v(),n(y);var k=o(y,4),b=s(k),ee=s(b);c(ee,"color: #00FF00"),v(),n(b);var x=o(b,2),I=s(x);c(I,"color: #FF0000");var te=o(I,2);c(te,"color: #00FF00"),v(),n(x);var T=o(x,2),oe=o(s(T));c(oe,"color: #6e6ef4"),v(),n(T),n(k);var z=o(k,2),V=o(s(z),2);c(V,"color: #00FF00");var M=o(V,2);c(M,"color: #FF0000");var re=o(M,2);c(re,"color: #6e6ef4"),v(3),n(z);var C=o(z,2),ae=o(s(C),2);c(ae,"color: #FF0000"),v(3),n(C),n(w);var D=o(w,2),G=s(D),se=o(s(G),2);ue(se,{get grid(){return m},get vectors(){return l(p)}}),n(G),n(D);var ne=o(D,2);pe(ne,{sketch:L}),ve(q,A),de()}export{Fe as component};
