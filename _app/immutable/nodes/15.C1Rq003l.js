import"../chunks/DsnmJJEf.js";import{o as ie}from"../chunks/hDrwkfIk.js";import{p as le,s as $,a as q,f as he,b as ve,c as de,d as pe,e as o,$ as s,g as l,u as G,h as O,z as v,a0 as n}from"../chunks/CY1iBhr2.js";import{V as R,s as c,P as ue}from"../chunks/DnDkWYNL.js";import{M as fe}from"../chunks/AbAXZCAX.js";import{M as ge}from"../chunks/Co6q3R2A.js";var me=he(`<!> <div><p>On the first screen you can drag the input vector <span>v1</span> the input vector. This is the vector we are calling <code>.reflect()</code> on.</p> <p>You can also drag the <span>normal</span> vector. This is the
        argument we pass to <code>v1.reflect(normal)</code>. It represent the normal vector of the
        surface that <span>v1</span> will be reflected on. This surface is rendered as the black line on the second screen.</p> <p>And you can observe how the <span>reflected</span> vector evolves.</p> <p>The second screen is another representation to help visualize how <code>.reflect</code> works. It shows:</p> <ul><li><span>v1</span> as pointing toward the surface it will be reflected
            on. (The surface is the black line).</li> <li><span>normal</span> pointing out of the surface at the
            point where <span>v1</span> intersects the surface.</li> <li>And <span>reflected</span> as going out from this impact
            point.</li></ul> <p><strong>Note</strong> how when <span>v1</span> and <span>normal</span> are perpendicular, ie. when the vector is parallel to the surface to reflect on, <span>reflected</span> keeps the same direction. In a physical simulation that's an edge case to handle before (or after)
        calling <code>.reflect()</code>.</p> <p><strong>Note</strong> the magnitude of the <span>normal</span> vector doesn't impact the result of <code>.reflect()</code> (Because the method normalize it
        before doing its computation)</p></div> <div class="results svelte-6zq5v2"><div><h3><code>Input</code></h3> <!></div></div> <!>`,1);function xe(S,Y){le(Y,!0);let A,f=$(q(new R(3,3))),g=$(q(new R(0,1))),j=G(()=>l(f).clone().reflect(l(g)));const E="#00FF00",H="#FF0000",J="#6e6ef4",u=G(()=>[{name:"v1",vec:l(f),color:E,onUpdate:e=>{O(f,e.clone().fixPrecision(1),!0)},isDraggable:!0},{name:"normal",vec:l(g),color:H,onUpdate:e=>{O(g,e.clone().fixPrecision(1),!0)},isDraggable:!0},{name:"v1.reflect(normal)",vec:l(j),color:J,isDraggable:!1}]),m={size:10,graduation:1},p=(e,t,a)=>{const r=e.width/2+a*t.x,i=e.height/2-a*t.y;e.strokeWeight(3);try{const d=t.clone().invert().rotateByDeg(45).resize(10);e.line(r,i,r+d.x,i-d.y);const h=t.clone().invert().rotateByDeg(-45).resize(10);e.line(r,i,r+h.x,i-h.y),e.line(e.width/2,e.height/2,r,i)}catch{e.circle(e.width/2,e.height/2,10)}},K=(e,t,a)=>{e.stroke(125,80),e.strokeWeight(1);for(let r=0;r<t.size/t.graduation;r++){const i=e.width/2+r*a*t.graduation;e.line(i,0,i,e.height);const d=e.width/2-r*a*t.graduation;e.line(d,0,d,e.height);const h=e.height/2+r*a*t.graduation;e.line(0,h,e.width,h);const W=e.height/2-r*a*t.graduation;e.line(0,W,e.width,W)}},L=(e,t)=>e.width/t.size,Q=e=>{e.setup=()=>{A=e,e.createCanvas(300,300)},e.draw=()=>{const t=L(e,m);e.background(240,240,240),K(e,m,t);const a=l(u)[0];e.stroke(a.color),e.push(),e.translate(-a.vec.x*t,a.vec.y*t),p(e,a.vec,t),e.pop();const r=l(u)[1];e.stroke(r.color),p(e,r.vec,t);const i=r.vec.clone().resize(10).rotateByDeg(90),d=r.vec.clone().resize(10).rotateByDeg(-90);e.stroke("black"),p(e,i,t),p(e,d,t);const h=l(u)[2];e.stroke(h.color),p(e,h.vec,t)}};ie(()=>{A?.remove()});var M=me(),P=ve(M);fe(P,{title:"Reflect methods"});var w=o(P,2),_=s(w),X=o(s(_));c(X,"color: #00FF00"),v(3),n(_);var F=o(_,2),V=o(s(F));c(V,"color: #FF0000");var Z=o(V,4);c(Z,"color: #00FF00"),v(),n(F);var y=o(F,2),ee=o(s(y));c(ee,"color: #6e6ef4"),v(),n(y);var b=o(y,4),k=s(b),te=s(k);c(te,"color: #00FF00"),v(),n(k);var x=o(k,2),B=s(x);c(B,"color: #FF0000");var oe=o(B,2);c(oe,"color: #00FF00"),v(),n(x);var I=o(x,2),re=o(s(I));c(re,"color: #6e6ef4"),v(),n(I),n(b);var z=o(b,2),T=o(s(z),2);c(T,"color: #00FF00");var C=o(T,2);c(C,"color: #FF0000");var ae=o(C,2);c(ae,"color: #6e6ef4"),v(3),n(z);var N=o(z,2),se=o(s(N),2);c(se,"color: #FF0000"),v(3),n(N),n(w);var D=o(w,2),U=s(D),ne=o(s(U),2);ge(ne,{get grid(){return m},get vectors(){return l(u)}}),n(U),n(D);var ce=o(D,2);ue(ce,{sketch:Q}),de(S,M),pe()}export{xe as component};
