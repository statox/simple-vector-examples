import"../chunks/DsnmJJEf.js";import{o as ie}from"../chunks/Dkdr-M-y.js";import{z as le,L as W,M as q,A as he,C as ve,F as de,G as ue,B as o,I as s,v as l,N as J,x as K,K as v,J as n}from"../chunks/B6V4Mh0Q.js";import{V as L,M as pe,s as c,a as fe,P as ge}from"../chunks/CPznaXQM.js";var me=he(`<!> <div><p>On the first screen you can drag the input vector <span>v1</span> the input vector. This is the vector we are calling <code>.reflect()</code> on.</p> <p>You can also drag the <span>normal</span> vector. This is the
        argument we pass to <code>v1.reflect(normal)</code>. It represent the normal vector of the
        surface that <span>v1</span> will be reflected on. This surface is rendered as the black line on the second screen.</p> <p>And you can observe how the <span>reflected</span> vector evolves.</p> <p>The second screen is another representation to help visualize how <code>.reflect</code> works. It shows:</p> <ul><li><span>v1</span> as pointing toward the surface it will be reflected
            on. (The surface is the black line).</li> <li><span>normal</span> pointing out of the surface at the
            point where <span>v1</span> intersects the surface.</li> <li>And <span>reflected</span> as going out from this impact
            point.</li></ul> <p><strong>Note</strong> how when <span>v1</span> and <span>normal</span> are perpendicular, ie. when the vector is parallel to the surface to reflect on, <span>reflected</span> keeps the same direction. In a physical simulation that's an edge case to handle before (or after)
        calling <code>.reflect()</code>.</p> <p><strong>Note</strong> the magnitude of the <span>normal</span> vector doesn't impact the result of <code>.reflect()</code> (Because the method normalize it
        before doing its computation)</p></div> <div class="results svelte-6zq5v2"><div><h3><code>Input</code></h3> <!></div></div> <!>`,1);function ke(O,R){le(R,!0);let A,f=W(q(new L(3,3))),g=W(q(new L(0,1))),S=J(()=>l(f).clone().reflect(l(g)));const Y="#00FF00",$="#FF0000",j="#6e6ef4",p=J(()=>[{name:"v1",vec:l(f),color:Y,onUpdate:e=>{K(f,e.clone().fixPrecision(1),!0)},isDraggable:!0},{name:"normal",vec:l(g),color:$,onUpdate:e=>{K(g,e.clone().fixPrecision(1),!0)},isDraggable:!0},{name:"v1.reflect(normal)",vec:l(S),color:j,isDraggable:!1}]),m={size:10,graduation:1},u=(e,t,a)=>{const r=e.width/2+a*t.x,i=e.height/2-a*t.y;e.strokeWeight(3);try{const d=t.clone().invert().rotateByDeg(45).resize(10);e.line(r,i,r+d.x,i-d.y);const h=t.clone().invert().rotateByDeg(-45).resize(10);e.line(r,i,r+h.x,i-h.y),e.line(e.width/2,e.height/2,r,i)}catch{e.circle(e.width/2,e.height/2,10)}},E=(e,t,a)=>{e.stroke(125,80),e.strokeWeight(1);for(let r=0;r<t.size/t.graduation;r++){const i=e.width/2+r*a*t.graduation;e.line(i,0,i,e.height);const d=e.width/2-r*a*t.graduation;e.line(d,0,d,e.height);const h=e.height/2+r*a*t.graduation;e.line(0,h,e.width,h);const U=e.height/2-r*a*t.graduation;e.line(0,U,e.width,U)}},H=(e,t)=>e.width/t.size,Q=e=>{e.setup=()=>{A=e,e.createCanvas(300,300)},e.draw=()=>{const t=H(e,m);e.background(240,240,240),E(e,m,t);const a=l(p)[0];e.stroke(a.color),e.push(),e.translate(-a.vec.x*t,a.vec.y*t),u(e,a.vec,t),e.pop();const r=l(p)[1];e.stroke(r.color),u(e,r.vec,t);const i=r.vec.clone().resize(10).rotateByDeg(90),d=r.vec.clone().resize(10).rotateByDeg(-90);e.stroke("black"),u(e,i,t),u(e,d,t);const h=l(p)[2];e.stroke(h.color),u(e,h.vec,t)}};ie(()=>{A?.remove()});var B=me(),I=ve(B);pe(I,{title:"Reflect methods"});var w=o(I,2),_=s(w),X=o(s(_));c(X,"color: #00FF00"),v(3),n(_);var F=o(_,2),M=o(s(F));c(M,"color: #FF0000");var Z=o(M,4);c(Z,"color: #00FF00"),v(),n(F);var y=o(F,2),ee=o(s(y));c(ee,"color: #6e6ef4"),v(),n(y);var k=o(y,4),b=s(k),te=s(b);c(te,"color: #00FF00"),v(),n(b);var x=o(b,2),P=s(x);c(P,"color: #FF0000");var oe=o(P,2);c(oe,"color: #00FF00"),v(),n(x);var V=o(x,2),re=o(s(V));c(re,"color: #6e6ef4"),v(),n(V),n(k);var z=o(k,2),C=o(s(z),2);c(C,"color: #00FF00");var T=o(C,2);c(T,"color: #FF0000");var ae=o(T,2);c(ae,"color: #6e6ef4"),v(3),n(z);var N=o(z,2),se=o(s(N),2);c(se,"color: #FF0000"),v(3),n(N),n(w);var D=o(w,2),G=s(D),ne=o(s(G),2);fe(ne,{get grid(){return m},get vectors(){return l(p)}}),n(G),n(D);var ce=o(D,2);ge(ce,{sketch:Q}),de(O,B),ue()}export{ke as component};
